---
alwaysApply: true
---
ControlAI Project Rules: Quality and Strategy Standards

Our Guide: This document establishes the rules and best practices for developing ControlAI. It is your reference for maintaining consistency, security, and performance while working in harmony with AI (Cursor).

You are an expert in TypeScript, Node.js, Vite/React, Supabase, Shadcn UI, Radix UI, and Tailwind.

1. Project Organization & Architecture

Use a logical directory structure, grouping files by domain (e.g., src/features/auth, src/features/dashboard).

Use the src/lib/ directory for low-level logic, such as the Supabase client instance and third-party utilities.

Place database migrations and Supabase Edge Functions inside the supabase/ directory at the project root.

For global or highly reusable components, use src/components/.

2. Supabase Integration

Separate Supabase client configurations for different environments (e.g., src/lib/supabase/client.ts).

Never access Supabase directly in React components for complex or sensitive logic; use backend APIs (such as Supabase Edge Functions) instead.

Enable Row Level Security (RLS) and Supabase Auth from day one.

Store all secret keys in environment variables and use .env or .env.local files for development secrets.

3. Code Style and Structure

Write concise, technical TypeScript with clear examples for the AI (Cursor).

Use comments to explain complex technical concepts and functions, making them easier for the AI to understand.

Prefer functional and declarative patterns in React.

Avoid code duplication by using helper functions and modular components.

Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).

A component’s file structure should follow: main exported component → subcomponents → helpers → statics → types.

4. Naming Conventions

Use lowercase letters with hyphens for directories (e.g., src/components/auth-wizard).

Use named exports for React components and functions.

Prefer interfaces for defining object types and props.

Avoid enums; use literal objects or string unions whenever possible.

5. TypeScript Usage

All code must be written in TypeScript.

Prefer interfaces for component props and data models.

Use functional components with clearly typed props.

Avoid using any; use unknown or explicit types when typing is not obvious.

6. UI and Styling

Use Shadcn UI (based on Radix UI) for interface components.

Use Tailwind CSS for layout, spacing, and utility styles.

Develop mobile-first and ensure the design is responsive by default.

Use Tailwind CSS dark: variants to support dark mode.

7. Performance Optimization

Minimize unnecessary use of useEffect and useState to reduce re-renders.

Lazy-load non-critical components to improve initial load time.

Optimize images: prefer modern formats like WebP/AVIF, include width/height, and use lazy loading.

8. State Management

Prefer local component state (useState, useReducer) for most cases.

For global state (authentication, themes), consider lightweight solutions or the React Context API.

Avoid complex state management libraries unless there is a proven need.

9. Linting and Code Quality

Use ESLint, Prettier, and TypeScript in strict mode.

Validate all data inputs (forms, APIs) with Zod or a similar library.

10. Developer Experience (DX)

The pnpm dev command must start the development environment without TypeScript or linter errors.

Document important architecture and code decisions in README.md or in docs/ directories.

11. Accessibility and UX

Use accessible primitives from Radix UI and components from Shadcn UI.

Ensure correct use of aria-* attributes, proper focus handling, and full keyboard support.

Maintain consistent spacing and typography for a good user experience.

12. Security

Environment Variables: Never expose secrets in the browser. Use .env for private keys and access them only in controlled environments (build time or Edge Functions).

Supabase Row Level Security (RLS): Always enable RLS on all tables. Write rules that validate user identity via auth.uid() or request.auth.

Auth Guards: Always use server-side validation (Edge Functions/APIs) for all sensitive logic. Never rely solely on client-side checks.

Supabase Client Access: Use the Supabase anon key on the client side only for public and safe queries. The service_role key must be used only in Edge Functions or secure environments.

Edge Functions: Validate all inputs with Zod. Store secrets in Supabase function environment variables, not in code.

Data Exposure Limitation: Return only the strictly necessary fields from the database.

Session Management: Use Supabase Auth session checks on protected routes.

Key Changes

Removal of references to the Next.js app/ router and Server Components/Server Actions concepts.

Adaptation of server.ts/client.ts to the frontend (Vite/React) and backend (Supabase Edge Functions) model.

Adjustments to Performance and State Management topics to focus on traditional React practices, without the complexity of the App Router.

Even stronger emphasis on security via Supabase and Edge Functions for the client-side context.